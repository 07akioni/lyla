{"version":3,"sources":["index.js","error.js","core.js","utils.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA,AGTA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createLyla = exports.LYLA_ERROR = exports.isLylaError = exports.defineLylaError = void 0;\nvar error_js_1 = require(\"./error.js\");\nObject.defineProperty(exports, \"defineLylaError\", { enumerable: true, get: function () { return error_js_1.defineLylaError; } });\nObject.defineProperty(exports, \"isLylaError\", { enumerable: true, get: function () { return error_js_1.isLylaError; } });\nObject.defineProperty(exports, \"LYLA_ERROR\", { enumerable: true, get: function () { return error_js_1.LYLA_ERROR; } });\nvar core_1 = require(\"./core\");\nObject.defineProperty(exports, \"createLyla\", { enumerable: true, get: function () { return core_1.createLyla; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isLylaError = exports.defineLylaError = exports.LYLA_ERROR = void 0;\nvar LYLA_ERROR;\n(function (LYLA_ERROR) {\n    /**\n     * Request encountered an error, fired by XHR `onerror` event. It doesn't mean\n     * your network has error, for example CORS error also triggers NETWORK_ERROR.\n     */\n    LYLA_ERROR[\"NETWORK\"] = \"NETWORK\";\n    /**\n     * Request is aborted.\n     */\n    LYLA_ERROR[\"ABORTED\"] = \"ABORTED\";\n    /**\n     * Response text is not valid JSON.\n     */\n    LYLA_ERROR[\"INVALID_JSON\"] = \"INVALID_JSON\";\n    /**\n     * Trying resolving `response.json` with `responseType='arraybuffer'` or\n     * `responseType='blob'`.\n     */\n    LYLA_ERROR[\"INVALID_CONVERSION\"] = \"INVALID_CONVERSION\";\n    /**\n     * Request timeout.\n     */\n    LYLA_ERROR[\"TIMEOUT\"] = \"TIMEOUT\";\n    /**\n     * HTTP status error.\n     */\n    LYLA_ERROR[\"HTTP\"] = \"HTTP\";\n    /**\n     * Request `options` is not valid. It's not a response error.\n     */\n    LYLA_ERROR[\"BAD_REQUEST\"] = \"BAD_REQUEST\";\n})(LYLA_ERROR = exports.LYLA_ERROR || (exports.LYLA_ERROR = {}));\nclass _LylaError extends Error {\n}\nfunction defineLylaError(lylaErrorProps, stack) {\n    const lylaError = new _LylaError();\n    lylaError.name = `LylaError[${lylaErrorProps.type}]`;\n    if (stack) {\n        lylaError.stack += stack;\n    }\n    return Object.assign(lylaError, lylaErrorProps);\n}\nexports.defineLylaError = defineLylaError;\nfunction isLylaError(error) {\n    return error instanceof _LylaError;\n}\nexports.isLylaError = isLylaError;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createLyla = void 0;\nconst error_js_1 = require(\"./error.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction isOkStatus(status) {\n    return 200 <= status && status < 300;\n}\nfunction createLyla(lylaOptions) {\n    async function request(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if ((_a = lylaOptions === null || lylaOptions === void 0 ? void 0 : lylaOptions.hooks) === null || _a === void 0 ? void 0 : _a.onInit) {\n            for (const hook of lylaOptions.hooks.onInit) {\n                options = await hook(options);\n            }\n        }\n        if ((_b = options === null || options === void 0 ? void 0 : options.hooks) === null || _b === void 0 ? void 0 : _b.onInit) {\n            for (const hook of options.hooks.onInit) {\n                options = await hook(options);\n            }\n        }\n        let _options = (0, utils_js_1.mergeOptions)(lylaOptions, options);\n        _options.method = (_c = _options.method) === null || _c === void 0 ? void 0 : _c.toUpperCase();\n        _options.responseType = options.responseType || 'text';\n        _options.url = _options.url || '';\n        if (_options.baseUrl) {\n            _options.url = (0, utils_js_1.mergeUrl)(_options.baseUrl, _options.url);\n        }\n        let stack;\n        try {\n            stack = (_d = new Error().stack) === null || _d === void 0 ? void 0 : _d.replace(/^Error/, '');\n        }\n        catch (_) { }\n        // Resolve query string, patch it to URL\n        if (_options.query) {\n            const urlSearchParams = new URLSearchParams(_options.query);\n            const queryString = urlSearchParams.toString();\n            if (_options.url.includes('?')) {\n                throw (0, error_js_1.defineLylaError)({\n                    type: error_js_1.LYLA_ERROR.BAD_REQUEST,\n                    message: \"`options.query` can't be set if `options.url` contains '?'\",\n                    detail: undefined,\n                    error: undefined,\n                    response: undefined\n                }, undefined);\n            }\n            if (queryString.length) {\n                _options.url = _options.url + '?' + queryString;\n            }\n        }\n        if ((_e = _options.hooks) === null || _e === void 0 ? void 0 : _e.onBeforeRequest) {\n            for (const hook of (_f = _options.hooks) === null || _f === void 0 ? void 0 : _f.onBeforeRequest) {\n                _options = await hook(_options);\n            }\n        }\n        // Move json data to body as string\n        if (_options.json !== undefined) {\n            if (_options.body !== undefined) {\n                throw (0, error_js_1.defineLylaError)({\n                    type: error_js_1.LYLA_ERROR.BAD_REQUEST,\n                    message: \"`options.json` can't be used together `options.body`. If you want to use `options.json`, you should left `options.body` as `undefined`\",\n                    detail: undefined,\n                    error: undefined,\n                    response: undefined\n                }, undefined);\n            }\n            _options.body = JSON.stringify(_options.json);\n        }\n        const { timeout, url = '', method = 'get', body, responseType = 'text', withCredentials = false, signal, onUploadProgress, onDownloadProgress } = _options;\n        async function handleResponseError(error) {\n            var _a, _b;\n            if ((_a = _options.hooks) === null || _a === void 0 ? void 0 : _a.onResponseError) {\n                for (const hook of (_b = _options.hooks) === null || _b === void 0 ? void 0 : _b.onResponseError) {\n                    await hook(error);\n                }\n            }\n        }\n        let _resolve;\n        let _reject;\n        // make request headers\n        const requestHeaders = {};\n        (0, utils_js_1.mergeHeaders)(requestHeaders, lylaOptions.headers);\n        (0, utils_js_1.mergeHeaders)(requestHeaders, options.headers);\n        // Set 'content-type' header\n        if (_options.json !== undefined) {\n            requestHeaders['content-type'] =\n                (_g = requestHeaders['content-type']) !== null && _g !== void 0 ? _g : 'application/json';\n        }\n        requestHeaders['accept'] = (_h = requestHeaders.accept) !== null && _h !== void 0 ? _h : '*/*';\n        _options.headers = requestHeaders;\n        let settled = false;\n        function cleanup() {\n            settled = true;\n            if (signal) {\n                signal.removeEventListener('abort', onAbortSignalReceived);\n            }\n        }\n        let aborted = false;\n        function onAbortSignalReceived() {\n            if (aborted)\n                return;\n            aborted = true;\n            const error = (0, error_js_1.defineLylaError)({\n                type: error_js_1.LYLA_ERROR.ABORTED,\n                message: 'Request aborted',\n                detail: undefined,\n                error: undefined,\n                response: undefined\n            }, stack);\n            handleResponseError(error);\n            _reject(error);\n            adapterHandle.abort();\n        }\n        if (signal) {\n            signal.addEventListener('abort', onAbortSignalReceived);\n        }\n        const adapterHandle = lylaOptions.adapter({\n            url,\n            method,\n            body,\n            json: _options.json,\n            headers: requestHeaders,\n            responseType,\n            withCredentials,\n            onNetworkError(detail) {\n                const error = (0, error_js_1.defineLylaError)({\n                    type: error_js_1.LYLA_ERROR.NETWORK,\n                    message: 'Network error',\n                    detail,\n                    error: undefined,\n                    response: undefined\n                }, stack);\n                handleResponseError(error);\n                _reject(error);\n            },\n            onDownloadProgress,\n            onUploadProgress,\n            async onResponse(resp, detail) {\n                var _a;\n                if (aborted)\n                    return;\n                cleanup();\n                let _json;\n                let _jsonIsSet = false;\n                let _cachedJson;\n                let _cachedJsonParsingError;\n                let response = {\n                    requestOptions: _options,\n                    status: resp.status,\n                    statusText: resp.statusText,\n                    headers: (0, utils_js_1.mergeHeaders)({}, resp.headers),\n                    body: resp.body,\n                    detail,\n                    set json(value) {\n                        _jsonIsSet = true;\n                        _json = value;\n                    },\n                    get json() {\n                        if (_jsonIsSet)\n                            return _json;\n                        if (responseType !== 'text') {\n                            const error = (0, error_js_1.defineLylaError)({\n                                type: error_js_1.LYLA_ERROR.INVALID_CONVERSION,\n                                message: `Can not convert ${responseType} to JSON`,\n                                detail: undefined,\n                                error: undefined,\n                                response\n                            }, undefined);\n                            handleResponseError(error);\n                            throw error;\n                        }\n                        if (_cachedJson === undefined) {\n                            try {\n                                return (_cachedJson = JSON.parse(resp.body));\n                            }\n                            catch (e) {\n                                _cachedJsonParsingError = e;\n                            }\n                        }\n                        else {\n                            return _cachedJson;\n                        }\n                        if (_cachedJsonParsingError) {\n                            const error = (0, error_js_1.defineLylaError)({\n                                type: error_js_1.LYLA_ERROR.INVALID_JSON,\n                                message: _cachedJsonParsingError.message,\n                                detail: undefined,\n                                error: _cachedJsonParsingError,\n                                response\n                            }, undefined);\n                            handleResponseError(error);\n                            throw error;\n                        }\n                    }\n                };\n                if (!isOkStatus(resp.status)) {\n                    const reason = `${resp.status} ${resp.statusText}`;\n                    const error = (0, error_js_1.defineLylaError)({\n                        type: error_js_1.LYLA_ERROR.HTTP,\n                        message: `Request failed with ${reason}`,\n                        detail: undefined,\n                        error: undefined,\n                        response\n                    }, stack);\n                    handleResponseError(error);\n                    _reject(error);\n                }\n                if ((_a = _options.hooks) === null || _a === void 0 ? void 0 : _a.onAfterResponse) {\n                    for (const hook of _options.hooks.onAfterResponse) {\n                        response = await hook(response);\n                    }\n                }\n                _resolve(response);\n            }\n        });\n        const requestPromise = new Promise((resolve, reject) => {\n            _resolve = resolve;\n            _reject = (e) => {\n                cleanup();\n                reject(e);\n            };\n        });\n        if (timeout) {\n            setTimeout(() => {\n                if (settled)\n                    return;\n                adapterHandle.abort();\n                aborted = true;\n                const error = (0, error_js_1.defineLylaError)({\n                    type: error_js_1.LYLA_ERROR.TIMEOUT,\n                    message: timeout\n                        ? `Timeout of ${timeout}ms exceeded`\n                        : 'Timeout exceeded',\n                    detail: undefined,\n                    error: undefined,\n                    response: undefined\n                }, stack);\n                handleResponseError(error);\n                _reject(error);\n            }, timeout);\n        }\n        if (method === 'GET' && body) {\n            throw (0, error_js_1.defineLylaError)({\n                type: error_js_1.LYLA_ERROR.BAD_REQUEST,\n                message: \"Can not send a request with body in 'GET' method.\",\n                error: undefined,\n                response: undefined,\n                detail: undefined\n            }, undefined);\n        }\n        return requestPromise;\n    }\n    function createRequestShortcut(method) {\n        return (url, options) => {\n            return request(Object.assign(Object.assign({}, options), { method,\n                url }));\n        };\n    }\n    function extend(options) {\n        const extendedOptions = (0, utils_js_1.mergeOptions)(lylaOptions, options);\n        return createLyla(extendedOptions).lyla;\n    }\n    return {\n        lyla: Object.assign(request, {\n            extend,\n            get: createRequestShortcut('get'),\n            post: createRequestShortcut('post'),\n            put: createRequestShortcut('put'),\n            patch: createRequestShortcut('patch'),\n            head: createRequestShortcut('head'),\n            delete: createRequestShortcut('delete'),\n            options: createRequestShortcut('options'),\n            trace: createRequestShortcut('trace'),\n            connect: createRequestShortcut('connect')\n        }),\n        catchError(handler) {\n            return (e) => {\n                if ((0, error_js_1.isLylaError)(e)) {\n                    return handler({ error: undefined, lylaError: e });\n                }\n                else {\n                    return handler({ error: e, lylaError: undefined });\n                }\n            };\n        },\n        matchError(error, matcher) {\n            if ((0, error_js_1.isLylaError)(error)) {\n                return matcher({ lylaError: error, error: undefined });\n            }\n            else {\n                return matcher({ lylaError: undefined, error });\n            }\n        }\n    };\n}\nexports.createLyla = createLyla;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeOptions = exports.mergeHeaders = exports.mergeUrl = void 0;\nfunction mergeUrl(baseUrl, relativeUrl) {\n    if (isAbsoluteUrl(relativeUrl)) {\n        return relativeUrl;\n    }\n    return relativeUrl\n        ? baseUrl.replace(/\\/+$/, '') + '/' + relativeUrl.replace(/^\\/+/, '')\n        : baseUrl;\n}\nexports.mergeUrl = mergeUrl;\nfunction isAbsoluteUrl(url) {\n    // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n    // by any combination of letters, digits, plus, period, or hyphen.\n    return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\nfunction isObject(value) {\n    return value && typeof value === 'object';\n}\nfunction mergeHeaders(target, source) {\n    if (!source)\n        return target;\n    for (const [key, value] of Object.entries(source)) {\n        if (value === undefined) {\n            delete target[key];\n        }\n        else {\n            target[key.toLowerCase()] = typeof value === 'string' ? value : `${value}`;\n        }\n    }\n    return target;\n}\nexports.mergeHeaders = mergeHeaders;\nfunction mergeOptions(...sources) {\n    let merged = {};\n    for (const source of sources) {\n        if (Array.isArray(source)) {\n            if (!Array.isArray(merged)) {\n                merged = [];\n            }\n            merged.push(...source);\n        }\n        else if (isObject(source)) {\n            for (let [key, value] of Object.entries(source)) {\n                if (isObject(value) && key in merged) {\n                    value = mergeOptions(merged[key], value);\n                }\n                merged[key] = value;\n            }\n        }\n    }\n    return merged;\n}\nexports.mergeOptions = mergeOptions;\n"]}